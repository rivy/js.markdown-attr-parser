{"version":3,"sources":["webpack://markdown-attr-parser/webpack/universalModuleDefinition","webpack://markdown-attr-parser/webpack/bootstrap","webpack://markdown-attr-parser/./src/index.js","webpack://markdown-attr-parser/./src/parser.pegjs"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;;AAEA,eAAe,mBAAO,CAAC,0CAAgB;;AAEvC;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,yBAAyB,EAAE;AACjF,sDAAsD,yBAAyB,EAAE;AACjF;;AAEA;AACA;AAC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;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA,yCAAyC,6BAA6B,iBAAiB,mBAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+CAA+C;AACzF,wBAAwB,6DAA6D;AACrF;AACA,eAAe;AACf;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"markdown-attr-parser\"] = factory();\n\telse\n\t\troot[\"markdown-attr-parser\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","'use strict';\n\n// spell-checker:ignore PEGjs\n\nconst parser = require('./parser.pegjs');\n\n// A valid output which means nothing has been parsed.\n// Used as error return / invalid output\nconst nothingHappened = {\n  prop: {},\n  eaten: '',\n};\n\nconst defaultConfig = {\n  defaultValue: () => undefined, // Its a function\n};\n\nfunction parse(value, indexNext, userConfig) {\n  const config = {...defaultConfig, ...userConfig};\n\n  // Make defaultValue a function if it isn't\n  if (typeof (config.defaultValue) !== 'function') {\n    const {defaultValue} = config;\n    config.defaultValue = () => defaultValue;\n  }\n\n  const prefix = (indexNext > 0) ? value.substr(0, indexNext) : '';\n  value = value.substr(indexNext);\n\n  try {\n    const parsed = parser.parse(value, config);\n    parsed.eaten = prefix + parsed.eaten;\n    return parsed;\n  } catch (_) {\n    return nothingHappened;\n  }\n}\n\nmodule.exports = parse;\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleIndices = { embedded_list: 0 },\n      peg$startRuleIndex   = 0,\n\n      peg$consts = [\n        peg$anyExpectation(),\n        function(a) { return a; },\n        \"<!--\",\n        peg$literalExpectation(\"<!--\", false),\n        \"-->\",\n        peg$literalExpectation(\"-->\", false),\n        function() { return normalize_attribute_list([], ''); },\n        \"{\",\n        peg$literalExpectation(\"{\", false),\n        \"}\",\n        peg$literalExpectation(\"}\", false),\n        function(a) { return normalize_attribute_list(a, text()); },\n        function(a, c) { return c; },\n        function(a, b) { a = a || []; return [].concat(a).concat(b); },\n        function(c) { return {class: c}; },\n        function(i) { return {id: i}; },\n        \"=\",\n        peg$literalExpectation(\"=\", false),\n        function(k, v) { return {key: k, value: v}; },\n        function(k) { return {key: k, value: ''}; },\n        function(k) { let retval = {key: k}; let v = default_value(k); if (typeof(v) !== 'undefined') { retval.value = v; }; return retval; },\n        peg$otherExpectation(\"whitespace\"),\n        /^[ \\t]/,\n        peg$classExpectation([\" \", \"\\t\"], false, false),\n        peg$otherExpectation(\"eol\"),\n        /^[\\r\\n]/,\n        peg$classExpectation([\"\\r\", \"\\n\"], false, false),\n        \"\\\\\",\n        peg$literalExpectation(\"\\\\\", false),\n        \" \",\n        peg$literalExpectation(\" \", false),\n        \"\\\"\",\n        peg$literalExpectation(\"\\\"\", false),\n        \"'\",\n        peg$literalExpectation(\"'\", false),\n        \"<\",\n        peg$literalExpectation(\"<\", false),\n        \">\",\n        peg$literalExpectation(\">\", false),\n        /^[^\\0-\\x1F]/,\n        peg$classExpectation([[\"\\0\", \"\\x1F\"]], true, false),\n        /^[^\\0-\\x1F \"'=<>{}]/,\n        peg$classExpectation([[\"\\0\", \"\\x1F\"], \" \", \"\\\"\", \"'\", \"=\", \"<\", \">\", \"{\", \"}\"], true, false),\n        peg$otherExpectation(\"escape sequence\"),\n        function(sequence) { return sequence; },\n        function() {return expected('non-EOL character');},\n        function(c) {return c;},\n        function(s) { return s.join(''); },\n        /^[^.\\0-\\x1F ={}]/,\n        peg$classExpectation([\".\", [\"\\0\", \"\\x1F\"], \" \", \"=\", \"{\", \"}\"], true, false),\n        function(c) { return c.join(''); },\n        /^[^.#\\0-\\x1F =<>{}]/,\n        peg$classExpectation([\".\", \"#\", [\"\\0\", \"\\x1F\"], \" \", \"=\", \"<\", \">\", \"{\", \"}\"], true, false),\n        function(text) { return text.join(''); },\n        \".\",\n        peg$literalExpectation(\".\", false),\n        function() { return text(); },\n        function(n) { return n; },\n        \"#\",\n        peg$literalExpectation(\"#\", false),\n        function(n) { return n.join(''); }\n      ],\n\n      peg$bytecode = [\n        peg$decode(\"%;!/B#$1\\\"\\\"5!7 0(*1\\\"\\\"5!7 &/($8\\\":!\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\"%$;$0#*;$&/U#2\\\"\\\"\\\"6\\\"7#/F$$;$0#*;$&/6$2$\\\"\\\"6$7%/'$8$:&$ )($'#(#'#(\\\"'#&'#.\\u0121 &%$;$0#*;$&/\\xAD#2\\\"\\\"\\\"6\\\"7#/\\x9E$$;$0#*;$&/\\x8E$2'\\\"\\\"6'7(/\\x7F$$;$0#*;$&/o$;\\\"/f$$;$0#*;$&/V$2)\\\"\\\"6)7*/G$$;$0#*;$&/7$2$\\\"\\\"6$7%/($8*:+*!$)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\x80 &%$;$0#*;$&/o#2'\\\"\\\"6'7(/`$$;$0#*;$&/P$;\\\"/G$$;$0#*;$&/7$2)\\\"\\\"6)7*/($8&:+&!\\\")(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;$0#*;$&/\\x93#;#.\\\" &\\\"/\\x85$$%$;$/&#0#*;$&&&#/2#;#/)$8\\\":,\\\"\\\"$ )(\\\"'#&'#0I*%$;$/&#0#*;$&&&#/2#;#/)$8\\\":,\\\"\\\"$ )(\\\"'#&'#&/)$8#:-#\\\"! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;8/&#0#*;8&&&#/' 8!:.!! ).\\xF1 &%;9/' 8!:/!! ).\\xDF &%;:/Q#$;$0#*;$&/A$20\\\"\\\"6071/2$;3/)$8$:2$\\\"# )($'#(#'#(\\\"'#&'#.\\xA1 &%;:/Q#$;$0#*;$&/A$20\\\"\\\"6071/2$;7/)$8$:2$\\\"# )($'#(#'#(\\\"'#&'#.c &%;:/G#$;$0#*;$&/7$20\\\"\\\"6071/($8#:3#!\\\")(#'#(\\\"'#&'#./ &%;:/' 8!:4!! )\"),\n        peg$decode(\"<46\\\"\\\"5!77=.\\\" 75\"),\n        peg$decode(\"<49\\\"\\\"5!7:=.\\\" 78\"),\n        peg$decode(\"2;\\\"\\\"6;7<\"),\n        peg$decode(\"2=\\\"\\\"6=7>\"),\n        peg$decode(\"2?\\\"\\\"6?7@\"),\n        peg$decode(\"2A\\\"\\\"6A7B\"),\n        peg$decode(\"20\\\"\\\"6071\"),\n        peg$decode(\"2C\\\"\\\"6C7D\"),\n        peg$decode(\"2E\\\"\\\"6E7F\"),\n        peg$decode(\"2'\\\"\\\"6'7(\"),\n        peg$decode(\"2)\\\"\\\"6)7*\"),\n        peg$decode(\"4G\\\"\\\"5!7H\"),\n        peg$decode(\"4I\\\"\\\"5!7J\"),\n        peg$decode(\";2.# &;/\"),\n        peg$decode(\"<%;&/7#;(.# &;)/($8\\\":L\\\"! )(\\\"'#&'#=.\\\" 7K\"),\n        peg$decode(\"%;(/\\xB1#$%%<;(=.##&&!&'#/B#;1.. &%;%/& 8!:M! )/($8\\\":N\\\"! )(\\\"'#&'#/[#0X*%%<;(=.##&&!&'#/B#;1.. &%;%/& 8!:M! )/($8\\\":N\\\"! )(\\\"'#&'#&&&#/1$;(/($8#:O#!!)(#'#(\\\"'#&'#.\\xBB &%;)/\\xB1#$%%<;)=.##&&!&'#/B#;1.. &%;%/& 8!:M! )/($8\\\":N\\\"! )(\\\"'#&'#/[#0X*%%<;)=.##&&!&'#/B#;1.. &%;%/& 8!:M! )/($8\\\":N\\\"! )(\\\"'#&'#&&&#/1$;)/($8#:O#!!)(#'#(\\\"'#&'#\"),\n        peg$decode(\"4P\\\"\\\"5!7Q\"),\n        peg$decode(\"%$;2.# &;0/,#0)*;2.# &;0&&&#/' 8!:R!! )\"),\n        peg$decode(\"4S\\\"\\\"5!7T\"),\n        peg$decode(\"%$;0/&#0#*;0&&&#/' 8!:U!! )\"),\n        peg$decode(\"%2V\\\"\\\"6V7W/\\xBE#%$2V\\\"\\\"6V7W0)*2V\\\"\\\"6V7W&/\\x93#%$%%<2V\\\"\\\"6V7W=.##&&!&'#/,#;4/#$+\\\")(\\\"'#&'#/K#0H*%%<2V\\\"\\\"6V7W=.##&&!&'#/,#;4/#$+\\\")(\\\"'#&'#&&&#/' 8!:R!! )/'$8\\\":X\\\" )(\\\"'#&'#/($8\\\":Y\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%2Z\\\"\\\"6Z7[/1#;5/($8\\\":Y\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%$;6/&#0#*;6&&&#/' 8!:\\\\!! )\")\n      ],\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleIndices)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$decode(s) {\n    var bc = new Array(s.length), i;\n\n    for (i = 0; i < s.length; i++) {\n      bc[i] = s.charCodeAt(i) - 32;\n    }\n\n    return bc;\n  }\n\n  function peg$parseRule(index) {\n    var bc    = peg$bytecode[index],\n        ip    = 0,\n        ips   = [],\n        end   = bc.length,\n        ends  = [],\n        stack = [],\n        params, i;\n\n    while (true) {\n      while (ip < end) {\n        switch (bc[ip]) {\n          case 0:\n            stack.push(peg$consts[bc[ip + 1]]);\n            ip += 2;\n            break;\n\n          case 1:\n            stack.push(void 0);\n            ip++;\n            break;\n\n          case 2:\n            stack.push(null);\n            ip++;\n            break;\n\n          case 3:\n            stack.push(peg$FAILED);\n            ip++;\n            break;\n\n          case 4:\n            stack.push([]);\n            ip++;\n            break;\n\n          case 5:\n            stack.push(peg$currPos);\n            ip++;\n            break;\n\n          case 6:\n            stack.pop();\n            ip++;\n            break;\n\n          case 7:\n            peg$currPos = stack.pop();\n            ip++;\n            break;\n\n          case 8:\n            stack.length -= bc[ip + 1];\n            ip += 2;\n            break;\n\n          case 9:\n            stack.splice(-2, 1);\n            ip++;\n            break;\n\n          case 10:\n            stack[stack.length - 2].push(stack.pop());\n            ip++;\n            break;\n\n          case 11:\n            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n            ip += 2;\n            break;\n\n          case 12:\n            stack.push(input.substring(stack.pop(), peg$currPos));\n            ip++;\n            break;\n\n          case 13:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1]) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 14:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1] === peg$FAILED) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 15:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1] !== peg$FAILED) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 16:\n            if (stack[stack.length - 1] !== peg$FAILED) {\n              ends.push(end);\n              ips.push(ip);\n\n              end = ip + 2 + bc[ip + 1];\n              ip += 2;\n            } else {\n              ip += 2 + bc[ip + 1];\n            }\n\n            break;\n\n          case 17:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (input.length > peg$currPos) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 18:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 19:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 20:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 21:\n            stack.push(input.substr(peg$currPos, bc[ip + 1]));\n            peg$currPos += bc[ip + 1];\n            ip += 2;\n            break;\n\n          case 22:\n            stack.push(peg$consts[bc[ip + 1]]);\n            peg$currPos += peg$consts[bc[ip + 1]].length;\n            ip += 2;\n            break;\n\n          case 23:\n            stack.push(peg$FAILED);\n            if (peg$silentFails === 0) {\n              peg$fail(peg$consts[bc[ip + 1]]);\n            }\n            ip += 2;\n            break;\n\n          case 24:\n            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];\n            ip += 2;\n            break;\n\n          case 25:\n            peg$savedPos = peg$currPos;\n            ip++;\n            break;\n\n          case 26:\n            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n            for (i = 0; i < bc[ip + 3]; i++) {\n              params[i] = stack[stack.length - 1 - params[i]];\n            }\n\n            stack.splice(\n              stack.length - bc[ip + 2],\n              bc[ip + 2],\n              peg$consts[bc[ip + 1]].apply(null, params)\n            );\n\n            ip += 4 + bc[ip + 3];\n            break;\n\n          case 27:\n            stack.push(peg$parseRule(bc[ip + 1]));\n            ip += 2;\n            break;\n\n          case 28:\n            peg$silentFails++;\n            ip++;\n            break;\n\n          case 29:\n            peg$silentFails--;\n            ip++;\n            break;\n\n          default:\n            throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n        }\n      }\n\n      if (ends.length > 0) {\n        end = ends.pop();\n        ip = ips.pop();\n      } else {\n        break;\n      }\n    }\n\n    return stack[0];\n  }\n\n\n      function default_value(key) {\n          return options.defaultValue ? options.defaultValue(key) : undefined;\n      }\n\n      function normalize_attribute_list(a, consumed) {\n          let retval = {};\n          retval.prop = {};\n          retval.eaten = consumed;\n          // * set id from first id tag\n          let id_elem = a && a.find( elem => elem.id );\n          if (id_elem) { retval.prop.id = id_elem.id; }\n          a.forEach( elem => {\n              // * convert class key to class type value\n              if (elem.key === 'class') { elem.class = [ elem.value ]; delete elem.key; delete elem.value; }\n              if (elem.class) {\n                  // * concat any new unique classes\n                  retval.prop.class = retval.prop.class || [];\n                  retval.prop.class = retval.prop.class.concat(elem.class.filter( item => retval.prop.class.indexOf(item) < 0 ));\n              }\n              else if (elem.id) {\n                  // * first id tag already used\n              }\n              else {\n                  if (elem.key === 'id') { retval.prop.id = retval.prop.id || elem.value; }\n                  else { retval.prop[elem.key] = retval.prop[elem.key] || elem.value; }\n              }\n              });\n          // retval._trace = a;\n          return retval;\n      }\n\n\n  peg$result = peg$parseRule(peg$startRuleIndex);\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n"],"sourceRoot":""}